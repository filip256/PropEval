// Logic proposition evaluator, available in python too
// Spaces are now ignored.

// Symbols:
// - atomic proposition: A-Z
// - parentheses: (, )
// - NOT: !
// - AND: ^
// - OR: v
// - IMPLICATION: >
// - EQUIVALENCE: =

// Interpretions can be added by the following syntax:
//   [expresion] | {definition for I1} {definition for I2}...
// Example:
//   ((P=Q)=(!(P=(!Q)))) | {!P,!Q} {!P,Q} {P,!Q} {P,Q}

#include <iostream>
#include <string.h>
using namespace std;

struct Node
{
	char symbol = 0;
	int father = -1, leaf[2] = { -1 };
	bool value = false, isInterpreted = false;

	void construct(const char s, const int f, const int l1, const int l2)
	{
		symbol = s;
		father = f;
		leaf[0] = l1;
		leaf[1] = l2;
	}
	void deconstruct()
	{
		symbol = 0;
		father = -1;
		leaf[0] = -1;
		leaf[1] = -1;
		value = false;
		isInterpreted = false;
	}
	void addInterpret(bool b)
	{
		isInterpreted = true;
		value = b;
	}
	bool append(const char s)
	{
		if (symbol != 0)
			return 0;
		symbol = s;
		return 1;
	}
};

Node node[100];

int getFreeNode(Node node[], const int size)
{ //return first unused node from the list
	for (int i = 1; i < size; i++)
	{
		if (node[i].symbol == 0 && node[i].father == -1)
			return i;
	}
	return -1;
}

bool recInt(int pos)
{ //recursive function for truth evaluating propositions
	if (node[pos].symbol == '!')
	{
		bool ls = recInt(node[pos].leaf[0]);
		cout << pos << " " << node[pos].symbol << " is " << !ls<<".\n";
		return !ls;
	}
	else if (node[pos].symbol == '^')
	{
		bool ls = recInt(node[pos].leaf[0]), rs = recInt(node[pos].leaf[1]);
		cout << pos << " " << node[pos].symbol << " is " << ls * rs << ".\n";
		return ls * rs;
	}
	else if (node[pos].symbol == 'v')
	{
		bool ls = recInt(node[pos].leaf[0]), rs = recInt(node[pos].leaf[1]);
		cout << pos << " " << node[pos].symbol << " is " << bool(ls + rs) << ".\n";
		return ls + rs;
	}
	else if (node[pos].symbol == '>')
	{
		bool ls = recInt(node[pos].leaf[0]), rs = recInt(node[pos].leaf[1]);
		if (ls && !rs)
		{
			cout << pos << " " << node[pos].symbol << " is 0.\n";
			return false;
		}
		cout << pos << " " << node[pos].symbol << " is 1.\n";
		return true;
	}
	else if (node[pos].symbol == '=')
	{
		bool ls = recInt(node[pos].leaf[0]), rs = recInt(node[pos].leaf[1]);
		if (ls != rs)
		{
			cout << pos << " " << node[pos].symbol << " is 0.\n";
			return false;
		}
		cout << pos << " " << node[pos].symbol << " is 1.\n";
		return true;
	}
	else
	{
		cout << pos << " " << node[pos].symbol << " is ";
		if (!node[pos].value)
			cout << "0 (interpreted atomic).\n";
		else
			cout << "1 (interpreted atomic).\n";
		return node[pos].value;
	}
}

bool insertChar(char s[], const char c, const int pos)
{
	if (pos > strlen(s) + 1)
		return 0;
	for (int i = strlen(s); i >= pos; i--)
		s[i + 1] = s[i];
	s[pos] = c;
	cout << "insLog: inserted " << c << " at " << pos <<" : "<<s<<".\n";
	return 1;
}

int main()
{
	int pos = 0, atoms[26][100];
	for (int i = 0; i < 26; i++) for (int j = 0; j < 100; j++) atoms[i][j] = -1;
	bool error = false;

	//read string
	char inputLine[1001];
	cin.getline(inputLine, 1000);

	//add first node
	node[0].construct(0, -1, -1, -1);
	cout << "Node 0 constructed.\n";

	int i = 0;
	while(inputLine[i] != 0)
	{
		while (inputLine[i] == ' ') i++; //ignore spaces

		if (inputLine[i] == '(')
		{ //add new node, connect it to previous node
			node[pos].leaf[0] = pos + 1;
			pos++;
			node[pos].construct(0, pos - 1, -1, -1);
			cout << i << ": '('   New node (" << pos << ") constructed, position set to " << pos << ".\n";
		}
		else if (inputLine[i] == ')')
		{ //move back one node
			if (node[pos].symbol == 0)
			{
				cout << i << ": ')'   Error: A proposition was expected.\n";
				error = true;
				break;
			}
			else
			{
				pos = node[pos].father;
				cout << i << ": ')'   Position set to " << pos << ".\n";
			}
		}
		else if (inputLine[i] == '!')
		{ //append '!' to past node
			node[pos].leaf[0] = pos + 1;
			if (!node[pos - 1].append('!'))
			{
				cout << i << ": '!'   Error: Node already appended.\n";
				error = true;
				break;
			}
			else
			{
				cout << i << ": '!'   Symbol appended to node (" << pos - 1 << ").\n";
			}
		}
		else if (inputLine[i] == 'v' || inputLine[i] == '^' || inputLine[i] == '>' || inputLine[i] == '=')
		{ //create a new leaf on the current node and move to it
			if (node[pos].leaf[0] == -1)
			{
				cout << i << ": '" << inputLine[i] << "'   Error: A proposition was expected.\n";
				error = true;
				break;
			}
			else
			{
				int auxPos = getFreeNode(node, 100);
				if (!node[pos].append(inputLine[i]))
				{
					cout << i << ": '" << inputLine[i] << "'   Error: Node already appended.\n";
					error = true;
					break;
				}
				else
				{
					node[pos].leaf[1] = auxPos;
					node[auxPos].construct(0, pos, -1, -1);
					pos = auxPos;
					cout << i << ": '" << inputLine[i] << "'   New node (" << pos << ") constructed, position set to " << pos << ".\n";
				}
			}
		}
		else if (inputLine[i] >= 'A' && inputLine[i] <= 'Z')
		{ //append atomic proposition and move to previous node
			if (!node[pos].append(inputLine[i]))
			{
				cout << i << ": '" << inputLine[i] << "'   Error: Node already appended.\n";
				error = true;
				break;
			}
			else
			{
				//save the nodes containing atoms for interpretation
				int k = 0; while (k < 100 && atoms[inputLine[i] - 'A'][k] != -1) k++;
				atoms[inputLine[i] - 'A'][k] = pos;

				pos = node[pos].father;
				cout << i << ": '" << inputLine[i] << "'   Position set to " << pos << ".\n";
			}
		}
		else if (inputLine[i] == '|') break;
		else
		{
			cout << i << ": '" << inputLine[i] << "'   Error: Unknown syntax.\n";
			error = true;
			break;
		}
		i++;
	}


	//evaluation output
	if (pos != -1 || error)
		cout << "Error: Proposition is ill-defined.\n";
	else
	{
		cout << "Proposition is well formed.\n";
		for (int i = 0; i < 100; i++)
			if (node[i].symbol != 0)
				cout << i << ' ' << node[i].symbol << "   leafs: " << node[i].leaf[0] << ',' << node[i].leaf[1] << '\n';
	}

	//interpretations
	if (inputLine[i] != 0)
		cout << "Logic evaluation based on given interpretations:\n";
	else
		cout << "No interpretations were given.\n";
	while (inputLine[i] != 0)// read interpretations
	{
		while (inputLine[i] == ' ') i++; //ignore spaces

		if (inputLine[i] == '{')
		{
			bool b = true;
			while (inputLine[i] && inputLine[i] != '}') //reading an interpretation
			{
				i++;
				if (inputLine[i] == '!')
					b = false;
				else if (inputLine[i] >= 'A' && inputLine[i] <= 'Z')
				{
					if (atoms[inputLine[i] - 'A'][0] != -1)
					{
						int k = 0;
						while (k < 100 && atoms[inputLine[i] - 'A'][k] != -1)
						{
							node[atoms[inputLine[i] - 'A'][k]].addInterpret(b);
							k++;
						}
						b = true;
					}
					else
						cout << "Error: '" << inputLine[i] << "' is not an atom in the given proposition.\n";
				}
			}
			bool ok = true;
			for (int i = 0; i < 100; i++) //check that all are interpreted
				if (node[i].symbol >= 'A' && node[i].symbol <= 'Z' && !node[i].isInterpreted)
				{
					ok = false;
					break;
				}
			if (ok)
			{
				cout<<"Truth value: "<< recInt(0)<<".\n";
			}
			else
				cout << "Error: Some atoms lack interpretation.\n";
		}
		i++;
	}

	//pause
	getchar();
	return 0;
}
