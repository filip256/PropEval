// Logic proposition evaluator.

// Symbols:
// - atomic proposition: A-Z
// - contradiction: f
// - tautology: t
// - parentheses: (, )
// - NOT: !
// - AND: ^
// - OR: v
// - IMPLICATION: >
// - EQUIVALENCE: =

// Interpretions can be added by the following syntax:
//   [expresion] | {definition for I1} {definition for I2}...
// Example:
//   ((P=Q)=(!(P=(!Q)))) | {!P,!Q} {P,!Q} {P,Q}
// Option:
//   [expresion] | @
//       generates all possible interpretations

// A graphical representation of the tree can now be opbained using DrawBinTree.exe (line 861).
// DrawBinTree.exe and it's source can be found here:
// Make sure DrawBinTree.exe is in the working dir of the main program.

// evaluates proposition in order to find if it is well formed using the graph based algorithm
// sorry it's not in python, I don't know enough of it yet but I'll come back when I do
#include <iostream>
#include <Windows.h>
#include <string.h>
using namespace std;

struct Node
{
	char symbol = 0;
	int father = -1, leaf[2] = { -1 };
	bool value = false, isInterpreted = false;

	void construct(const char s, const int f, const int l1, const int l2)
	{
		symbol = s;
		father = f;
		leaf[0] = l1;
		leaf[1] = l2;
	}
	void deconstruct()
	{
		symbol = 0;
		father = -1;
		leaf[0] = -1;
		leaf[1] = -1;
		value = false;
		isInterpreted = false;
	}
	void addInterpret(bool b)
	{
		isInterpreted = true;
		value = b;
	}
	bool append(const char s)
	{
		if (symbol != 0)
			return 0;
		symbol = s;
		return 1;
	}
};

struct TableColumn
{
	char exp[1001] = { 0 };
	int valueNumber;
	bool values[256];
};

struct TransformRule
{
	Node from[100], to[100]; 
};

Node node[1000];
TableColumn table[1001];
TransformRule simplifications[10];


int atoms[26][1000];
char treeString[100][100];
bool verbose = true;

void clearTree(const int size)
{
	for (int i = 0; i < size; i++)
		node[i].deconstruct();
}

void clearAtomsList()
{
	for (int i = 0; i < 26; i++)
		for (int j = 0; j < 1000; j++)
			atoms[i][j] = -1;
}

int getFreeNode(const int size)
{ //return first unused node from the list
	for (int i = 1; i < size; i++)
	{
		if (node[i].symbol == 0 && node[i].father == -1)
			return i;
	}
	return -1;
}

int getAtomCount()
{
	int c = 0;
	for (int i = 0; i < 26; i++)
		if (atoms[i][0] != -1)
			c++;
	return c;
}

bool recInt(int pos)
{
	if (node[pos].symbol == '!')
	{
		bool ls = recInt(node[pos].leaf[0]);
		//cout << pos << " " << node[pos].symbol << " is " << !ls<<".\n";
		node[pos].value = !ls;
		return !ls;
	}
	else if (node[pos].symbol == '^')
	{
		bool ls = recInt(node[pos].leaf[0]), rs = recInt(node[pos].leaf[1]);
		//cout << pos << " " << node[pos].symbol << " is " << ls * rs << ".\n";
		node[pos].value = ls * rs;
		return ls * rs;
	}
	else if (node[pos].symbol == 'v')
	{
		bool ls = recInt(node[pos].leaf[0]), rs = recInt(node[pos].leaf[1]);
		//cout << pos << " " << node[pos].symbol << " is " << bool(ls + rs) << ".\n";
		node[pos].value = ls + rs;
		return ls + rs;
	}
	else if (node[pos].symbol == '|')
	{
		bool ls = recInt(node[pos].leaf[0]), rs = recInt(node[pos].leaf[1]);
		//cout << pos << " " << node[pos].symbol << " is " << ls * rs << ".\n";
		node[pos].value = !(ls * rs);
		return !(ls * rs);
	}
	else if (node[pos].symbol == '*')
	{
		bool ls = recInt(node[pos].leaf[0]), rs = recInt(node[pos].leaf[1]);
		//cout << pos << " " << node[pos].symbol << " is " << bool(ls + rs) << ".\n";
		node[pos].value = !(ls + rs);
		return !(ls + rs);
	}
	else if (node[pos].symbol == '>')
	{
		bool ls = recInt(node[pos].leaf[0]), rs = recInt(node[pos].leaf[1]);
		if (ls && !rs)
		{
			//cout << pos << " " << node[pos].symbol << " is 0.\n";
			node[pos].value = false;
			return false;
		}
		//cout << pos << " " << node[pos].symbol << " is 1.\n";
		node[pos].value = true;
		return true;
	}
	else if (node[pos].symbol == '=')
	{
		bool ls = recInt(node[pos].leaf[0]), rs = recInt(node[pos].leaf[1]);
		if (ls != rs)
		{
			//cout << pos << " " << node[pos].symbol << " is 0.\n";
			node[pos].value = false;
			return false;
		}
		//cout << pos << " " << node[pos].symbol << " is 1.\n";
		node[pos].value = true;
		return true;
	}
	else if(node[pos].symbol >= 'A' && node[pos].symbol <= 'Z')
	{
		//cout << pos << " " << node[pos].symbol << " is ";
		/*
		if (!node[pos].value)
			cout << "0 (interpreted atomic).\n";
		else
			cout << "1 (interpreted atomic).\n";
		*/
		return node[pos].value;
	}
	else
	{
		//cout << pos << " " << node[pos].symbol << " is ";
		//if (!node[pos].value)
		//	cout << "0 (contradiction).\n";
		//else
		//	cout << "1 (tautology).\n";
		return node[pos].value;
	}
}

void getTreeDepth(int pos, int currentD, int &maxD)
{
	if (currentD > maxD)
		maxD = currentD;

	if (node[pos].symbol == '!')
		getTreeDepth(node[pos].leaf[0], currentD + 1, maxD);
	else if (node[pos].symbol == '^' || node[pos].symbol == 'v' || node[pos].symbol == '>' || node[pos].symbol == '=' || node[pos].symbol == '|' || node[pos].symbol == '*')
	{
		getTreeDepth(node[pos].leaf[0], currentD + 1, maxD);
		getTreeDepth(node[pos].leaf[1], currentD + 1, maxD);
	}
}

void recTreeString(int pos, int x, int y)
{
	if (node[pos].symbol == '!')
	{
		treeString[y][x] = '!';

		int depth = 0;
		getTreeDepth(pos, 0, depth);

		for(int i = 0; i < depth; i++)
			treeString[y + i + 1][x - i - 1] = '/';
		recTreeString(node[pos].leaf[0], x - depth - 1, y + depth + 1);
	}
	else if (node[pos].symbol == '^' || node[pos].symbol == 'v' || node[pos].symbol == '>' || node[pos].symbol == '=' || node[pos].symbol == '|' || node[pos].symbol == '*')
	{
		treeString[y][x] = node[pos].symbol;

		int depth = 0;
		getTreeDepth(pos, 0, depth);

		for (int i = 0; i < depth; i++)
		{
			treeString[y + i + 1][x - i - 1] = '/';
			treeString[y + i + 1][x + i + 1] = '\\';
		}
		recTreeString(node[pos].leaf[0], x - depth - 1, y + depth + 1);
		recTreeString(node[pos].leaf[1], x + depth + 1, y + depth + 1);
	}
	else if (node[pos].symbol >= 'A' && node[pos].symbol <= 'Z' || node[pos].symbol == 'f' || node[pos].symbol == 't')
	{
		treeString[y][x] = node[pos].symbol;
	}
}

bool insertChar(char s[], const char c, const int pos)
{
	//cout << "insLog: inserted " << c << " at " << pos <<" : "<<s<<".\n";
	if (pos > strlen(s) + 1 || pos < 0)
		return false;
	for (int i = strlen(s); i >= pos; i--)
		s[i + 1] = s[i];
	s[pos] = c;
	return true;
}

bool popChar(char s[], const int pos)
{
	if (pos >= strlen(s) || pos < 0)
		return false;
	for (int i = pos; s[i]; i++)
		s[i] = s[i + 1];
	//cout << "popLog: poped at " << pos << " : " << s << ".\n";
	return true;
}

void getAllInterpretations(const int atomCnt, char s[])
{ //generate all interpretations for n atoms
	int n = 1;
	for (int i = 0; i < atomCnt; i++)
		n *= 2;

	for (int i = 0; i < n; i++)
	{
		insertChar(s, '{', strlen(s));
		int b = i, a = 0, ai = 25;
		while (a < atomCnt)
		{
			if (b % 2 == 0)
				insertChar(s, '!', strlen(s));

			//find next atom
			while (atoms[ai][0] == -1) ai--;

			insertChar(s, ai + 'A', strlen(s));
			b /= 2;
			ai--;
			a++;
		}
		insertChar(s, '}', strlen(s));
	}
}

void getStrongExp(char s[])
{ //a naive implementation
	bool isGood = true;
	int len = strlen(s);

	for (int i = len - 1; i >= 0; i--)
	{ // negations
		if (s[i] == '!')
		{ //find first atom or end of parentheses after
			int j = i + 1, paranth = 0;
			while (s[j] && (((s[j] < 'A' || s[j] > 'Z') && (s[j] != 'f' && s[j] != 't')) || paranth != 0) && (s[j] != ')' || paranth != 1))
			{
				if (s[j] == '(') paranth++;
				else if (s[j] == ')') paranth--;
				j++;
			}
			insertChar(s, ')', j + 1);
			insertChar(s, '(', i);
			len += 2;
		}
	}
	
	for (int i = len - 1; i >= 0; i--)
	{ // ^ and v
		if (s[i] == 'v' || s[i] == '^' || s[i] == '|' || s[i] == '*')
		{ //find first atom or end of parentheses
			int j = i + 1, paranth = 0;
			while (s[j] && (((s[j] < 'A' || s[j] > 'Z') && (s[j] != 'f' && s[j] != 't')) || paranth != 0) && (s[j] != ')' || paranth != 1))
			{
				if (s[j] == '(') paranth++;
				else if (s[j] == ')') paranth--;
				j++;
			}
			insertChar(s, ')', j + 1);

			j = i - 1; paranth = 0;

			while (s[j] && (((s[j] < 'A' || s[j] > 'Z') && (s[j] != 'f' && s[j] != 't')) || paranth != 0) && (s[j] != '(' || paranth != 1))
			{
				if (s[j] == ')') paranth++;
				else if (s[j] == '(') paranth--;
				j--;
			}
			insertChar(s, '(', j);

			len += 2;
		}
	}

	for (int i = len - 1; i >= 0; i--)
	{ // for >
		if (s[i] == '>')
		{ //find first atom or end of parentheses
			int j = i + 1, paranth = 0;
			while (s[j] && (((s[j] < 'A' || s[j] > 'Z') && (s[j] != 'f' && s[j] != 't')) || paranth != 0) && (s[j] != ')' || paranth != 1))
			{
				if (s[j] == '(') paranth++;
				else if (s[j] == ')') paranth--;
				j++;
			}
			insertChar(s, ')', j + 1);

			j = i - 1; paranth = 0;

			while (s[j] && (((s[j] < 'A' || s[j] > 'Z') && (s[j] != 'f' && s[j] != 't')) || paranth != 0) && (s[j] != '(' || paranth != 1))
			{
				if (s[j] == ')') paranth++;
				else if (s[j] == '(') paranth--;
				j--;
			}
			insertChar(s, '(', j);

			len += 2;
		}
	}

	for (int i = len - 1; i >= 0; i--)
	{ // for =
		if (s[i] == '=')
		{ //find first atom or end of parentheses
			int j = i + 1, paranth = 0;
			while (s[j] && (((s[j] < 'A' || s[j] > 'Z') && (s[j] != 'f' && s[j] != 't')) || paranth != 0) && (s[j] != ')' || paranth != 1))
			{
				if (s[j] == '(') paranth++;
				else if (s[j] == ')') paranth--;
				j++;
			}
			insertChar(s, ')', j + 1);

			j = i - 1; paranth = 0;

			while (s[j] && (((s[j] < 'A' || s[j] > 'Z') && (s[j] != 'f' && s[j] != 't')) || paranth != 0) && (s[j] != '(' || paranth != 1))
			{
				if (s[j] == ')') paranth++;
				else if (s[j] == '(') paranth--;
				j--;
			}
			insertChar(s, '(', j);

			len += 2;
		}
	}

	//remove excess parentheses
	for (int i = 0; s[i + 1]; i++)
	{
		if (s[i] == '(' && s[i + 1] == '(')
		{ //find the pair of s[i + 1]
			int j = i + 2, paranth = 1;
			while (s[j] && paranth != 0)
			{
				if (s[j] == '(') paranth++;
				else if (s[j] == ')') paranth--;
				j++;
			}
			if (s[j] == ')')
			{
				popChar(s, j - 1);
				popChar(s, i + 1);
				i--;
			}
		}
	}
}

void loadIntToTable(int i, int pos, int &tablePos)
{ //doesnt load atoms
	if (node[pos].symbol == '!')
	{
		table[tablePos--].values[i] = node[pos].value;

		loadIntToTable(i, node[pos].leaf[0], tablePos);
	}
	else if (node[pos].symbol == '^' || node[pos].symbol == 'v' || node[pos].symbol == '>' || node[pos].symbol == '=' || node[pos].symbol == '|' || node[pos].symbol == '*')
	{
		table[tablePos--].values[i] = node[pos].value;

		loadIntToTable(i, node[pos].leaf[0], tablePos);
		loadIntToTable(i, node[pos].leaf[1], tablePos);
	}
}

int readInterpretation(char s[])
{
	int i = 0, ind = 0;
	while (s[i] != 0)// read interpretations
	{
		while (s[i] == ' ') i++; //ignore spaces

		if (s[i] == '{')
		{
			bool b = true;
			while (s[i] && s[i] != '}') //reading an interpretation
			{
				i++;
				if (s[i] == '!')
					b = false;
				else if (s[i] >= 'A' && s[i] <= 'Z')
				{
					if (atoms[s[i] - 'A'][0] != -1)
					{
						int k = 0;
						while (k < 100 && atoms[s[i] - 'A'][k] != -1)
						{
							node[atoms[s[i] - 'A'][k]].addInterpret(b);
							k++;
						}
						b = true;
					}
					else
						cout << "Error: '" << s[i] << "' is not an atom in the given proposition.\n";
				}
			}
			bool ok = true;
			for (int i = 0; i < 100; i++) //check that all are interpreted
				if (node[i].symbol >= 'A' && node[i].symbol <= 'Z' && !node[i].isInterpreted)
				{
					ok = false;
					break;
				}
			if (ok)
			{ // interpretation output
				cout << "Truth value: " << recInt(0) << ".\n";
				//load subtree values
				int aux = getFreeNode(1001) - 1;
				loadIntToTable(ind, 0, aux);
				//load atom value
				aux = 0;
				for (int i = 0; i < 26; i++)
					if (atoms[i][0] != -1)
						table[aux++].values[ind] = node[atoms[i][0]].value;
				ind++;
			}
			else
				cout << "Error: Some atoms lack interpretation.\n";
		}
		i++;
	}
	return ind;
}

bool getTree(char s[])
{
	node[0].construct(0, -1, -1, -1);
	cout << "Node 0 constructed.\n";

	int pos = 0, i = 0;
	bool error = false;
	while (s[i] != 0)
	{
		//while (s[i] == ' ') i++; //ignore spaces

		if (s[i] == '(')
		{ //add new node, connect it to previous node
			node[pos].leaf[0] = pos + 1;
			pos++;
			node[pos].construct(0, pos - 1, -1, -1);
			cout << i << ": '('      New node (" << pos << ") constructed, position set to " << pos << ".\n";
		}
		else if (s[i] == ')')
		{ //move back one node
			if (node[pos].symbol == 0)
			{
				cout << i << ": ')'      Error: A proposition was expected.\n";
				error = true;
				break;
			}
			else
			{
				pos = node[pos].father;
				cout << i << ": ')'      Position set to " << pos << ".\n";
			}
		}
		else if (s[i] == '!')
		{ //append '!' to past node
			node[pos].leaf[0] = pos + 1;
			if (!node[pos - 1].append('!'))
			{
				cout << i << ": '!'      Error: Node already appended.\n";
				error = true;
				break;
			}
			else
			{
				cout << i << ": '!'      Symbol appended to node (" << pos - 1 << ").\n";
			}
		}
		else if (s[i] == 'v' || s[i] == '^' || s[i] == '>' || s[i] == '=' || s[i] == '|' || s[i] == '*')
		{ //create a new leaf on the current node and move to it
			if (node[pos].leaf[0] == -1)
			{
				cout << i << ": '" << s[i] << "'      Error: A proposition was expected.\n";
				error = true;
				break;
			}
			else
			{
				int auxPos = getFreeNode(1000);
				if (!node[pos].append(s[i]))
				{
					cout << i << ": '" << s[i] << "'      Error: Node already appended.\n";
					error = true;
					break;
				}
				else
				{
					node[pos].leaf[1] = auxPos;
					node[auxPos].construct(0, pos, -1, -1);
					pos = auxPos;
					cout << i << ": '" << s[i] << "'      New node (" << pos << ") constructed, position set to " << pos << ".\n";
				}
			}
		}
		else if (s[i] >= 'A' && s[i] <= 'Z')
		{ //append atomic proposition and move to previous node
			if (!node[pos].append(s[i]))
			{
				cout << i << ": '" << s[i] << "'      Error: Node already appended.\n";
				error = true;
				break;
			}
			else
			{
				//save the nodes containing atoms for interpretation
				int k = 0; while (k < 1000 && atoms[s[i] - 'A'][k] != -1) k++;
				atoms[s[i] - 'A'][k] = pos;

				node[pos].leaf[0] = -1; node[pos].leaf[1] = -1; //why is this needed? sometimes atoms get leafs out of nowhere...memory leaks maybe??
				pos = node[pos].father;
				cout << i << ": '" << s[i] << "'      Position set to " << pos <<" leaf1: "<< node[pos].leaf[0] << " leaf2: " << node[pos].leaf[1] << ".\n";
			}
		}
		else if (s[i] == 'f')
		{ //append FALSE and move to previous node
			if (!node[pos].append(s[i]))
			{
				cout << i << ": '" << s[i] << "'      Error: Node already appended.\n";
				error = true;
				break;
			}
			else
			{
				node[pos].value = false; node[pos].isInterpreted = true;
				node[pos].leaf[0] = -1; node[pos].leaf[1] = -1; //why is this needed? sometimes atoms get leafs out of nowhere...memory leaks maybe??
				pos = node[pos].father;
				cout << i << ": 'FALSE'  Position set to " << pos << ".\n";
			}
		}
		else if (s[i] == 't')
		{ //append FALSE and move to previous node
			if (!node[pos].append(s[i]))
			{
				cout << i << ": '" << s[i] << "'      Error: Node already appended.\n";
				error = true;
				break;
			}
			else
			{
				node[pos].value = true; node[pos].isInterpreted = true;
				pos = node[pos].father;
				cout << i << ": 'TRUE'   Position set to " << pos << ".\n";
			}
		}
		else if (s[i] == '#') break;
		else if(s[i] != ' ')
		{
			cout << i << ": '" << s[i] << "'      Error: Unknown syntax.\n";
			error = true;
			break;
		}
		i++;
	}


	//evaluation output
	if (pos != -1 || error)
	{
		cout << "Error: Proposition is ill-defined.\n";
		return 0;
	}

	cout << "Proposition is well formed.\n";
	for (int i = 0; i < 100; i++)
		if (node[i].symbol != 0)
			cout << i << ' ' << node[i].symbol << "   leafs: " << node[i].leaf[0] << ',' << node[i].leaf[1] <<"   father:   "<< node[i].father<< '\n';
	return 1;
}

void recTableExp(int pos, int ins, char s[])
{ // truns a tree or subtree back into a strong expression
	if (node[pos].symbol == '!')
	{
		insertChar(s, '!', ins);
		insertChar(s, ')', ins + 1);
		insertChar(s, '(', ins);
		recTableExp(node[pos].leaf[0], ins + 2, s);
	}
	else if (node[pos].symbol == '^' || node[pos].symbol == 'v' || node[pos].symbol == '>' || node[pos].symbol == '=' || node[pos].symbol == '|' || node[pos].symbol == '*')
	{
		insertChar(s, node[pos].symbol, ins);
		insertChar(s, ')', ins + 1);
		insertChar(s, '(', ins);

		recTableExp(node[pos].leaf[1], ins + 2, s);
		recTableExp(node[pos].leaf[0], ins + 1, s);
	}
	else if (node[pos].symbol >= 'A' && node[pos].symbol <= 'Z' || node[pos].symbol == 'f' || node[pos].symbol == 't')
		insertChar(s, node[pos].symbol, ins);
}

void getTableHeader(int pos, int &tablePos)
{ //fills the table header, doesnt add atoms
	if (node[pos].symbol == '!')
	{
		table[tablePos].exp[0] = 0;
		recTableExp(pos, 0, table[tablePos--].exp);

		getTableHeader(node[pos].leaf[0], tablePos);
	}
	else if (node[pos].symbol == '^' || node[pos].symbol == 'v' || node[pos].symbol == '>' || node[pos].symbol == '=' || node[pos].symbol == '|' || node[pos].symbol == '*')
	{
		table[tablePos].exp[0] = 0;
		recTableExp(pos, 0, table[tablePos--].exp);

		getTableHeader(node[pos].leaf[0], tablePos);
		getTableHeader(node[pos].leaf[1], tablePos);
	}
}

int buildTable()
{ //builds a table by getting the header (axcepting atoms) then adding atoms from atom list and removing spaces(if an atom si used twice a space is wrongfully created)
	int treeLen = getFreeNode(1001) - 1, l = 0;
	getTableHeader(0, treeLen);

	for (int i = 0; i < 26; i++)
		if (atoms[i][0] != -1)
			table[l++].exp[0] = i + 'A';

	treeLen = getFreeNode(1001);
	int tableLen = treeLen;
	for (int i = 0; i < treeLen; i++)
		if (table[i].exp[0] == 0)
		{
			for (int j = i; j + 1 < treeLen; j++)
				table[j] = table[j + 1];
			i--;
			tableLen--;
		}
	return tableLen;
}

void printTable(int tableLen, int interpretationCnt)
{ //tedious low level formating...
	//header
	cout << 'É';
	for (int i = 0; i < tableLen - 1; i++)
	{
		for (int j = 0; table[i].exp[j]; j++)
			cout << 'Í';
		cout << 'Ñ';
	}
	for (int j = 0; table[tableLen - 1].exp[j]; j++)
		cout << 'Í';
	cout << "»\nº";
	for (int i = 0; i < tableLen - 1; i++)
		cout << table[i].exp << '³';
	cout << table[tableLen - 1].exp << "º\nÌ";
	for (int i = 0; i < tableLen - 1; i++)
	{
		for (int j = 0; table[i].exp[j]; j++)
			cout << 'Í';
		cout << 'Ø';
	}
	for (int j = 0; table[tableLen - 1].exp[j]; j++)
		cout << 'Í';
	cout << "¹\n";

	for (int i = 0; i < interpretationCnt - 1; i++)
	{
		//value line
		cout << 'º';
		for (int j = 0; j < tableLen - 1; j++)
		{
			for (int k = 0; k < strlen(table[j].exp) - 1; k++)
				cout << ' ';
			cout << table[j].values[i] << '³';
		}
		for (int k = 0; k < strlen(table[tableLen - 1].exp) - 1; k++)
			cout << ' ';
		cout << table[tableLen - 1].values[i] << "º\n";
		//table line
		cout << 'Ç';
		for (int j = 0; j < tableLen - 1; j++)
		{
			for (int k = 0; k < strlen(table[j].exp); k++)
				cout << 'Ä';
			cout << 'Å';
		}
		for (int k = 0; k < strlen(table[tableLen - 1].exp); k++)
			cout << 'Ä';
		cout << "¶\n";
	}
	//final value line
	cout << 'º';
	for (int j = 0; j < tableLen - 1; j++)
	{
		for (int k = 0; k < strlen(table[j].exp) - 1; k++)
			cout << ' ';
		cout << table[j].values[interpretationCnt - 1] << '³';
	}
	for (int k = 0; k < strlen(table[tableLen - 1].exp) - 1; k++)
		cout << ' ';
	cout << table[tableLen - 1].values[interpretationCnt - 1] << "º\n";
	//final table line
	cout << 'È';
	for (int j = 0; j < tableLen - 1; j++)
	{
		for (int k = 0; k < strlen(table[j].exp); k++)
			cout << 'Í';
		cout << 'Ï';
	}
	for (int k = 0; k < strlen(table[tableLen - 1].exp); k++)
		cout << 'Í';
	cout << "¼\n";
}

void call(LPCSTR lpApplicationName, char arg[])
{
	STARTUPINFOA si;
	PROCESS_INFORMATION pi;

	SecureZeroMemory(&si, sizeof(si));
	si.cb = sizeof(si);
	SecureZeroMemory(&pi, sizeof(pi));

	// call program
	CreateProcessA(lpApplicationName,arg,NULL,NULL,FALSE,CREATE_NEW_CONSOLE,NULL,NULL,&si,&pi);
	CloseHandle(pi.hProcess);
	CloseHandle(pi.hThread);
}

void drawGraphSFML()
{
	//graphics
	char graphStr[10001] = { 0 };
	//int treeLen = getFreeNode(1001);
	for (int i = 0; i < 1000; i++)
	{
		if (node[i].symbol)
		{
			insertChar(graphStr, node[i].symbol, strlen(graphStr));
			if (node[i].leaf[0] != -1)
			{
				insertChar(graphStr, '[', strlen(graphStr));
				int n = strlen(graphStr), sl = node[i].leaf[0];
				while (sl)
				{
					insertChar(graphStr, sl % 10 + '0', n);
					sl /= 10;
				}
				insertChar(graphStr, ']', strlen(graphStr));
			}
			if (node[i].leaf[1] != -1)
			{
				insertChar(graphStr, '[', strlen(graphStr));
				int n = strlen(graphStr), sl = node[i].leaf[1];
				while (sl)
				{
					insertChar(graphStr, sl % 10 + '0', n);
					sl /= 10;
				}
				insertChar(graphStr, ']', strlen(graphStr));
			}
		}
	}
	cout << graphStr << '\n';
	call("DrawBinTree.exe", graphStr);
}


bool compareTreesDIFF(int posTree1, int posTree2, Node tree2[])
{
	cout << node[posTree1].symbol << ' ' << tree2[posTree2].symbol << '\n';
	if (tree2[posTree2].symbol >= 'A' && tree2[posTree2].symbol <= 'Z')
		return true;
	else if (node[posTree1].symbol == '!' && tree2[posTree2].symbol == '!')
		return true * compareTreesDIFF(node[posTree1].leaf[0], tree2[posTree2].leaf[0], tree2);
	else if ((node[posTree1].symbol == '^' && tree2[posTree2].symbol == '^') || (node[posTree1].symbol == 'v' && tree2[posTree2].symbol == 'v') || (node[posTree1].symbol == '>' && tree2[posTree2].symbol == '>') || (node[posTree1].symbol == '=' && tree2[posTree2].symbol == '=') || (node[posTree1].symbol == '*' && tree2[posTree2].symbol == '*') || (node[posTree1].symbol == '|' && tree2[posTree2].symbol == '|'))
		return true * compareTreesDIFF(node[posTree1].leaf[0], tree2[posTree2].leaf[0], tree2) * compareTreesDIFF(node[posTree1].leaf[1], tree2[posTree2].leaf[1], tree2);
	return false;
}

bool compareTrees(int posTree1, int posTree2)
{
	cout << node[posTree1].symbol << ' ' << node[posTree2].symbol << '\n';
	if (node[posTree1].symbol == node[posTree2].symbol)
	{
		if (node[posTree1].symbol == '!')
			return true * compareTrees(node[posTree1].leaf[0], node[posTree2].leaf[0]);
		else if (node[posTree1].symbol == '^' || node[posTree1].symbol == 'v' || node[posTree1].symbol == '>' || node[posTree1].symbol == '=' || node[posTree1].symbol == '*' || node[posTree1].symbol == '|')
			return true * (compareTrees(node[posTree1].leaf[0], node[posTree2].leaf[0]) * compareTrees(node[posTree1].leaf[1], node[posTree2].leaf[1]) + compareTrees(node[posTree1].leaf[0], node[posTree2].leaf[1]) * compareTrees(node[posTree1].leaf[1], node[posTree2].leaf[0]));
		return true;
	}
	return false;
}

void addTree(int pos, Node tree2[])
{
	int free = getFreeNode(1000);
	if(free != -1)
		node[free].construct(tree2[pos].symbol, tree2[pos].father, tree2[pos].leaf[0], tree2[pos].leaf[1]);

	if (tree2[pos].symbol == '!')
		addTree(tree2[pos].leaf[0], tree2);
	else if (tree2[pos].symbol == '^' || tree2[pos].symbol == 'v' || tree2[pos].symbol == '>' || tree2[pos].symbol == '=' || tree2[pos].symbol == '*' || tree2[pos].symbol == '|')
	{
		addTree(tree2[pos].leaf[0], tree2);
		addTree(tree2[pos].leaf[1], tree2);
	}
}

void updateAtomsList(int pos)
{
	if (node[pos].symbol >= 'A' && node[pos].symbol <= 'Z')
	{
		for (int i = 0; i < 1000; i++)
			if (atoms[node[pos].symbol - 65][i] == -1)
			{
				atoms[node[pos].symbol - 65][i] = pos;
				break;
			}
	}
	else if (node[pos].symbol == '!')
	{
		updateAtomsList(node[pos].leaf[0]);
	}
	else if (node[pos].symbol == '^' || node[pos].symbol == 'v' || node[pos].symbol == '>' || node[pos].symbol == '=' || node[pos].symbol == '*' || node[pos].symbol == '|')
	{
		updateAtomsList(node[pos].leaf[0]);
		updateAtomsList(node[pos].leaf[1]);
	}
}


//Simplifacation and normal forms
void defragmentTree(int pos)
{
	int free;
	if (node[0].symbol == 0)
		free = 0;
	else
		free = getFreeNode(1000);
	if (pos > free)
	{
		if (pos == node[node[pos].father].leaf[1])
			node[node[pos].father].leaf[1] = free;
		else
			node[node[pos].father].leaf[0] = free;

		node[free].construct(node[pos].symbol, node[pos].father, node[pos].leaf[0], node[pos].leaf[1]);

		node[node[pos].leaf[0]].father = free;
		node[node[pos].leaf[1]].father = free;

		node[pos].deconstruct();
		pos = free;
	}

	//parsing
	if (node[pos].symbol == '!')
	{
		defragmentTree(node[pos].leaf[0]);
	}
	else if (node[pos].symbol == '^' || node[pos].symbol == 'v' || node[pos].symbol == '>' || node[pos].symbol == '=' || node[pos].symbol == '*' || node[pos].symbol == '|')
	{
		defragmentTree(node[pos].leaf[0]);
		defragmentTree(node[pos].leaf[1]);
	}
}

void copyTree(int pos, int &newPos)
{
	int free = getFreeNode(1000);
	if(newPos == -1) //only do this first time
		newPos = free;
	if (free != -1)
		node[free].construct(node[pos].symbol, node[pos].father, node[pos].leaf[0], node[pos].leaf[1]);

	if (node[pos].symbol == '!')
		copyTree(node[pos].leaf[0], newPos);
	else if (node[pos].symbol == '^' || node[pos].symbol == 'v' || node[pos].symbol == '>' || node[pos].symbol == '=' || node[pos].symbol == '*' || node[pos].symbol == '|')
	{
		copyTree(node[pos].leaf[0], newPos);
		copyTree(node[pos].leaf[1], newPos);
	}
}

void deleteTree(int pos)
{
	if (node[pos].symbol == '!')
		deleteTree(node[pos].leaf[0]);
	else if (node[pos].symbol == '^' || node[pos].symbol == 'v' || node[pos].symbol == '>' || node[pos].symbol == '=' || node[pos].symbol == '|' || node[pos].symbol == '*')
	{
		deleteTree(node[pos].leaf[0]);
		deleteTree(node[pos].leaf[1]);
	}
	node[pos].deconstruct();
}

bool compareValues(int posTree1, int posTree2)
{
	char s[10001] = {0};
	getAllInterpretations(getAtomCount(), s);

	bool isEqual = true;
	int i = 0;
	while (s[i] != 0)// read interpretations
	{
		while (s[i] == ' ') i++; //ignore spaces

		if (s[i] == '{')
		{
			bool b = true;
			while (s[i] && s[i] != '}') //reading an interpretation
			{
				i++;
				if (s[i] == '!')
					b = false;
				else if (s[i] >= 'A' && s[i] <= 'Z')
				{
					if (atoms[s[i] - 'A'][0] != -1)
					{
						int k = 0;
						while (k < 100 && atoms[s[i] - 'A'][k] != -1)
						{
							node[atoms[s[i] - 'A'][k]].addInterpret(b);
							k++;
						}
						b = true;
					}
					else
						cout << "Error: '" << s[i] << "' is not an atom in the given proposition.\n";
				}
			}
			if (recInt(posTree1) != recInt(posTree2))
			{
				isEqual = false;
				break;
			}
		}
		i++;
	}
	return isEqual;
}

bool reverseCompareValues(int posTree1, int posTree2)
{
	char s[10001] = { 0 };
	getAllInterpretations(getAtomCount(), s);

	bool isEqual = true;
	int i = 0;
	while (s[i] != 0)// read interpretations
	{
		while (s[i] == ' ') i++; //ignore spaces

		if (s[i] == '{')
		{
			bool b = true;
			while (s[i] && s[i] != '}') //reading an interpretation
			{
				i++;
				if (s[i] == '!')
					b = false;
				else if (s[i] >= 'A' && s[i] <= 'Z')
				{
					if (atoms[s[i] - 'A'][0] != -1)
					{
						int k = 0;
						while (k < 100 && atoms[s[i] - 'A'][k] != -1)
						{
							node[atoms[s[i] - 'A'][k]].addInterpret(b);
							k++;
						}
						b = true;
					}
					else
						cout << "Error: '" << s[i] << "' is not an atom in the given proposition.\n";
				}
			}
			if (recInt(posTree1) == recInt(posTree2))
			{
				isEqual = false;
				break;
			}
		}
		i++;
	}
	return isEqual;
}

bool isTautology(int posTree1)
{
	char s[10001] = { 0 };
	
	getAllInterpretations(getAtomCount(), s);

	bool isEqual = true;
	int i = 0;
	while (s[i] != 0)// read interpretations
	{
		while (s[i] == ' ') i++; //ignore spaces

		if (s[i] == '{')
		{
			bool b = true;
			while (s[i] && s[i] != '}') //reading an interpretation
			{
				i++;
				if (s[i] == '!')
					b = false;
				else if (s[i] >= 'A' && s[i] <= 'Z')
				{
					if (atoms[s[i] - 'A'][0] != -1)
					{
						int k = 0;
						while (k < 100 && atoms[s[i] - 'A'][k] != -1)
						{
							node[atoms[s[i] - 'A'][k]].addInterpret(b);
							k++;
						}
						b = true;
					}
					else
						cout << "Error: '" << s[i] << "' is not an atom in the given proposition.\n";
				}
			}
			if (recInt(posTree1) == 0)
			{
				isEqual = false;
				break;
			}
		}
		i++;
	}
	return isEqual;
}

bool isContradiction(int posTree1)
{
	char s[10001] = { 0 };
	getAllInterpretations(getAtomCount(), s);

	bool isEqual = true;
	int i = 0;
	while (s[i] != 0)// read interpretations
	{
		while (s[i] == ' ') i++; //ignore spaces

		if (s[i] == '{')
		{
			bool b = true;
			while (s[i] && s[i] != '}') //reading an interpretation
			{
				i++;
				if (s[i] == '!')
					b = false;
				else if (s[i] >= 'A' && s[i] <= 'Z')
				{
					if (atoms[s[i] - 'A'][0] != -1)
					{
						int k = 0;
						while (k < 100 && atoms[s[i] - 'A'][k] != -1)
						{
							node[atoms[s[i] - 'A'][k]].addInterpret(b);
							k++;
						}
						b = true;
					}
					else
						cout << "Error: '" << s[i] << "' is not an atom in the given proposition.\n";
				}
			}
			if (recInt(posTree1) == 1)
			{
				isEqual = false;
				break;
			}
		}
		i++;
	}
	return isEqual;
}

void simplify(int pos, int &startPos, bool &isChange)
{

}

void simplifyu(int pos, int &startPos, bool &isChange)
{	
	if (node[pos].symbol == '^')
	{
		if (reverseCompareValues(node[pos].leaf[0], node[pos].leaf[1])) //annihilation
		{
			if (verbose)
			{
				char exp[1001] = { 0 };
				recTableExp(node[pos].leaf[0], 0, exp);
				cout << "Annihilation: " << exp << " ^ ";
				memset(exp, 0, 1001);
				recTableExp(node[pos].leaf[1], 0, exp);
				cout << exp<< " -> ";
			}

			node[pos].symbol = 'f';
			deleteTree(node[pos].leaf[0]);
			deleteTree(node[pos].leaf[1]);
			node[pos].leaf[0] = -1;
			node[pos].leaf[1] = -1;
			isChange = true;

			if (verbose)
			{
				char exp[1001] = { 0 };
				recTableExp(pos, 0, exp);
				cout <<exp<<'\n';
			}
		}
		else if (node[node[pos].leaf[0]].symbol == 't' || isTautology(node[pos].leaf[0]) && false) // conjunction with tautology 1
		{
			if (verbose)
			{
				char exp[1000] = { 0 };
				recTableExp(node[pos].leaf[0], 0, exp);
				cout << "Conjunction with tautology: " << exp << " ^ ";
				memset(exp, 0, 1000);
				recTableExp(node[pos].leaf[1], 0, exp);
				cout << exp << " -> ";
			}

			int endPos = node[pos].leaf[1];
			node[endPos].father = node[pos].father;
			if (node[pos].father == -1)
				startPos = endPos;
			if (node[pos].father != -1)
			{
				if (pos == node[node[pos].father].leaf[1])
					node[node[pos].father].leaf[1] = endPos;
				else
					node[node[pos].father].leaf[0] = endPos;
				deleteTree(node[pos].leaf[0]);
			}
			else
			{
				deleteTree(node[pos].leaf[0]);
				node[pos].deconstruct();
			}
			pos = endPos;
			isChange = true;

			if (verbose)
			{
				char exp[1000] = { 0 };
				recTableExp(pos, 0, exp);
				cout << exp << '\n';
			}
		}
		else if (node[node[pos].leaf[1]].symbol == 't' || isTautology(node[pos].leaf[1]) && false) // conjunction with tautology 2
		{
			if (verbose)
			{
				char exp[1000] = { 0 };
				recTableExp(node[pos].leaf[0], 0, exp);
				cout << "Conjunction with tautology: " << exp << " ^ ";
				memset(exp, 0, 1000);
				recTableExp(node[pos].leaf[1], 0, exp);
				cout << exp << " -> ";
			}
			int endPos = node[pos].leaf[0];
			node[endPos].father = node[pos].father;
			if (node[pos].father == -1)
				startPos = endPos;
			if (node[pos].father != -1)
			{
				if (pos == node[node[pos].father].leaf[1])
					node[node[pos].father].leaf[1] = endPos;
				else
					node[node[pos].father].leaf[0] = endPos;
				deleteTree(node[pos].leaf[1]);
			}
			else
			{
				deleteTree(node[pos].leaf[1]);
				node[pos].deconstruct();
			}
			pos = endPos;
			isChange = true;

			if (verbose)
			{
				char exp[1000] = { 0 };
				recTableExp(pos, 0, exp);
				cout << exp << '\n';
			}
		}
		else if (node[node[pos].leaf[0]].symbol == 'f' || node[node[pos].leaf[1]].symbol == 'f' || isContradiction(node[pos].leaf[0]) || isContradiction(node[pos].leaf[1]) && false) // conjunction with contradiction
		{
			if (verbose)
			{
				char exp[1000] = { 0 };
				recTableExp(node[pos].leaf[0], 0, exp);
				cout << "Conjunction with contradiction: " << exp << " ^ ";
				memset(exp, 0, 1000);
				recTableExp(node[pos].leaf[1], 0, exp);
				cout << exp << " -> ";
			}
			node[pos].symbol = 'f';
			node[node[pos].leaf[0]].deconstruct();
			node[node[pos].leaf[1]].deconstruct();
			node[pos].leaf[0] = -1;
			node[pos].leaf[1] = -1;

			isChange = true;

			if (verbose)
			{
				char exp[1000] = { 0 };
				recTableExp(pos, 0, exp);
				cout << exp << '\n';
			}
		}
		else if (compareValues(node[pos].leaf[0], node[pos].leaf[1])) //idempocy simplification
		{
		if (verbose)
		{
			char exp[1000] = { 0 };
			recTableExp(node[pos].leaf[0], 0, exp);
			cout << "Idempocy: " << exp << " ^ ";
			memset(exp, 0, 1000);
			recTableExp(node[pos].leaf[1], 0, exp);
			cout << exp << " -> ";
		}
		int endPos = node[pos].leaf[0];
		node[endPos].father = node[pos].father;
		if (node[pos].father == -1)
			startPos = endPos;
		if (node[pos].father != -1)
		{
			if (pos == node[node[pos].father].leaf[1])
				node[node[pos].father].leaf[1] = endPos;
			else
				node[node[pos].father].leaf[0] = endPos;
			deleteTree(node[pos].leaf[1]);
		}
		else
		{
			deleteTree(node[pos].leaf[1]);
			node[pos].deconstruct();
		}
		pos = endPos;
		isChange = true;

		if (verbose)
		{
			char exp[1000] = { 0 };
			recTableExp(pos, 0, exp);
			cout << exp << '\n';
		}
		}
		else if (node[node[pos].leaf[0]].symbol == 'v') //absorbtion 1
		{
			if (compareValues(node[pos].leaf[1], node[node[pos].leaf[0]].leaf[0])) //side 1A
			{
				if (verbose)
				{
					char exp[1000] = { 0 };
					recTableExp(node[pos].leaf[0], 0, exp);
					cout << "Absorbtion: " << exp << " ^ ";
					memset(exp, 0, 1000);
					recTableExp(node[pos].leaf[1], 0, exp);
					cout << exp << " -> ";
				}

				int endPos = node[pos].leaf[1];
				node[endPos].father = node[pos].father;
				if (node[pos].father == -1)
					startPos = endPos;
				if (node[pos].father != -1)
				{
					if (pos == node[node[pos].father].leaf[1])
						node[node[pos].father].leaf[1] = endPos;
					else
						node[node[pos].father].leaf[0] = endPos;
					deleteTree(node[pos].leaf[0]);
				}
				else
				{
					deleteTree(node[pos].leaf[0]);
					node[pos].deconstruct();
				}
				pos = endPos;
				isChange = true;

				if (verbose)
				{
					char exp[1000] = { 0 };
					recTableExp(pos, 0, exp);
					cout << exp << '\n';
				}
			}
			else if (compareValues(node[pos].leaf[1], node[node[pos].leaf[0]].leaf[1])) //side 1B
			{
				if (verbose)
				{
					char exp[1000] = { 0 };
					recTableExp(node[pos].leaf[0], 0, exp);
					cout << "Absorbtion: " << exp << " ^ ";
					memset(exp, 0, 1000);
					recTableExp(node[pos].leaf[1], 0, exp);
					cout << exp << " -> ";
				}

				int endPos = node[pos].leaf[1];
				node[endPos].father = node[pos].father;
				if (node[pos].father == -1)
					startPos = endPos;
				if (node[pos].father != -1)
				{
					if (pos == node[node[pos].father].leaf[1])
						node[node[pos].father].leaf[1] = endPos;
					else
						node[node[pos].father].leaf[0] = endPos;
					deleteTree(node[pos].leaf[0]);
				}
				else
				{
					deleteTree(node[pos].leaf[0]);
					node[pos].deconstruct();
				}
				pos = endPos;
				isChange = true;

				if (verbose)
				{
					char exp[1000] = { 0 };
					recTableExp(pos, 0, exp);
					cout << exp << '\n';
				}
			}
		}
		else if (node[node[pos].leaf[1]].symbol == 'v') // absorbtion 2
		{
			if (compareValues(node[pos].leaf[0], node[node[pos].leaf[1]].leaf[0])) //side 2A
			{
				if (verbose)
				{
					char exp[1000] = { 0 };
					recTableExp(node[pos].leaf[0], 0, exp);
					cout << "Absorbtion: " << exp << " ^ ";
					memset(exp, 0, 1000);
					recTableExp(node[pos].leaf[1], 0, exp);
					cout << exp << " -> ";
				}

				int endPos = node[pos].leaf[0];
				node[endPos].father = node[pos].father;
				if (node[pos].father == -1)
					startPos = endPos;
				if (node[pos].father != -1)
				{
					if (pos == node[node[pos].father].leaf[1])
						node[node[pos].father].leaf[1] = endPos;
					else
						node[node[pos].father].leaf[0] = endPos;
					deleteTree(node[pos].leaf[1]);
				}
				else
				{
					deleteTree(node[pos].leaf[1]);
					node[pos].deconstruct();
				}
				pos = endPos;
				isChange = true;

				if (verbose)
				{
					char exp[1000] = { 0 };
					recTableExp(pos, 0, exp);
					cout << exp << '\n';
				}
			}
			else if (compareValues(node[pos].leaf[0], node[node[pos].leaf[1]].leaf[1])) //side 2B
			{
				if (verbose)
				{
					char exp[1000] = { 0 };
					recTableExp(node[pos].leaf[0], 0, exp);
					cout << "Absorbtion: " << exp << " ^ ";
					memset(exp, 0, 1000);
					recTableExp(node[pos].leaf[1], 0, exp);
					cout << exp << " -> ";
				}

				int endPos = node[pos].leaf[0];
				node[endPos].father = node[pos].father;
				if (node[pos].father == -1)
					startPos = endPos;
				if (node[pos].father != -1)
				{
					if (pos == node[node[pos].father].leaf[1])
						node[node[pos].father].leaf[1] = endPos;
					else
						node[node[pos].father].leaf[0] = endPos;
					deleteTree(node[pos].leaf[1]);
				}
				else
				{
					deleteTree(node[pos].leaf[1]);
					node[pos].deconstruct();
				}
				pos = endPos;
				isChange = true;

				if (verbose)
				{
					char exp[1000] = { 0 };
					recTableExp(pos, 0, exp);
					cout << exp << '\n';
				}
			}
		}
	}

	if(node[pos].symbol == 'v')
	{
		if (reverseCompareValues(node[pos].leaf[0], node[pos].leaf[1]))
		{
			if (verbose)
			{
				char exp[1001] = { 0 };
				recTableExp(node[pos].leaf[0], 0, exp);
				cout << "Annihilation: " << exp << " v ";
				memset(exp, 0, 1001);
				recTableExp(node[pos].leaf[1], 0, exp);
				cout << exp << " -> ";
			}

			node[pos].symbol = 't';
			deleteTree(node[pos].leaf[0]);
			deleteTree(node[pos].leaf[1]);
			node[pos].leaf[0] = -1;
			node[pos].leaf[1] = -1;
			isChange = true;

			if (verbose)
			{
				char exp[1001] = { 0 };
				recTableExp(pos, 0, exp);
				cout << exp << '\n';
			}
		}
		else if (node[node[pos].leaf[0]].symbol == 'f' || isContradiction(node[pos].leaf[0]) && false) // disjunction with contradiction 1
		{
			if (verbose)
			{
				char exp[1001] = { 0 };
				recTableExp(node[pos].leaf[0], 0, exp);
				cout << "Disjunction with contradiction: " << exp << " v ";
				memset(exp, 0, 1001);
				recTableExp(node[pos].leaf[1], 0, exp);
				cout << exp << " -> ";
			}

			int endPos = node[pos].leaf[1];
			node[endPos].father = node[pos].father;
			if (node[pos].father == -1)
				startPos = endPos;
			if (node[pos].father != -1)
			{
				if (pos == node[node[pos].father].leaf[1])
					node[node[pos].father].leaf[1] = endPos;
				else
					node[node[pos].father].leaf[0] = endPos;
				deleteTree(node[pos].leaf[0]);
			}
			else
			{
				deleteTree(node[pos].leaf[0]);
				node[pos].deconstruct();
			}
			pos = endPos;
			isChange = true;

			if (verbose)
			{
				char exp[1001] = { 0 };
				recTableExp(pos, 0, exp);
				cout << exp << '\n';
			}
		}
		else if (node[node[pos].leaf[1]].symbol == 'f' || isContradiction(node[pos].leaf[1]) && false) // conjunction with contradiction 2
		{
			if (verbose)
			{
				char exp[1001] = { 0 };
				recTableExp(node[pos].leaf[0], 0, exp);
				cout << "Disjunction with contradiction: " << exp << " v ";
				memset(exp, 0, 1001);
				recTableExp(node[pos].leaf[1], 0, exp);
				cout << exp << " -> ";
			}
			int endPos = node[pos].leaf[0];
			node[endPos].father = node[pos].father;
			if (node[pos].father == -1)
				startPos = endPos;
			if (node[pos].father != -1)
			{
				if (pos == node[node[pos].father].leaf[1])
					node[node[pos].father].leaf[1] = endPos;
				else
					node[node[pos].father].leaf[0] = endPos;
				deleteTree(node[pos].leaf[1]);
			}
			else
			{
				deleteTree(node[pos].leaf[1]);
				node[pos].deconstruct();
			}
			pos = endPos;
			isChange = true;

			if (verbose)
			{
				char exp[1001] = { 0 };
				recTableExp(pos, 0, exp);
				cout << exp << '\n';
			}
		}
		else if (node[node[pos].leaf[0]].symbol == 't' || node[node[pos].leaf[1]].symbol == 't' || isTautology(node[pos].leaf[0]) || isTautology(node[pos].leaf[1]) && false) // disjunction with contradiction
		{
			if (verbose)
			{
				char exp[1001] = { 0 };
				recTableExp(node[pos].leaf[0], 0, exp);
				cout << "Disjunction with tautology: " << exp << " v ";
				memset(exp, 0, 1001);
				recTableExp(node[pos].leaf[1], 0, exp);
				cout << exp << " -> ";
			}

			node[pos].symbol = 't';
			node[node[pos].leaf[0]].deconstruct();
			node[node[pos].leaf[1]].deconstruct();
			node[pos].leaf[0] = -1;
			node[pos].leaf[1] = -1;

			isChange = true;

			if (verbose)
			{
				char exp[1001] = { 0 };
				recTableExp(pos, 0, exp);
				cout << exp << '\n';
			}
		}
		else if (compareValues(node[pos].leaf[0], node[pos].leaf[1])) //idempocy simplification
		{
		if (verbose)
		{
			char exp[1001] = { 0 };
			recTableExp(node[pos].leaf[0], 0, exp);
			cout << "Idempocy: " << exp << " v ";
			memset(exp, 0, 1001);
			recTableExp(node[pos].leaf[1], 0, exp);
			cout << exp << " -> ";
		}

		int endPos = node[pos].leaf[0];
		node[endPos].father = node[pos].father;
		if (node[pos].father == -1)
			startPos = endPos;
		if (node[pos].father != -1)
		{
			if (pos == node[node[pos].father].leaf[1])
				node[node[pos].father].leaf[1] = endPos;
			else
				node[node[pos].father].leaf[0] = endPos;
			deleteTree(node[pos].leaf[1]);
		}
		else
		{
			deleteTree(node[pos].leaf[1]);
			node[pos].deconstruct();
		}
		pos = endPos;
		isChange = true;

		if (verbose)
		{
			char exp[1001] = { 0 };
			recTableExp(pos, 0, exp);
			cout << exp << '\n';
		}
		}
		else if (node[node[pos].leaf[0]].symbol == '^') //absorbtion 1
		{
			if (compareValues(node[pos].leaf[1], node[node[pos].leaf[0]].leaf[0])) //side 1A
			{
				if (verbose)
				{
					char exp[1001] = { 0 };
					recTableExp(node[pos].leaf[0], 0, exp);
					cout << "Absorbtion: " << exp << " v ";
					memset(exp, 0, 1001);
					recTableExp(node[pos].leaf[1], 0, exp);
					cout << exp << " -> ";
				}

				int endPos = node[pos].leaf[1];
				node[endPos].father = node[pos].father;
				if (node[pos].father == -1)
					startPos = endPos;
				if (node[pos].father != -1)
				{
					if (pos == node[node[pos].father].leaf[1])
						node[node[pos].father].leaf[1] = endPos;
					else
						node[node[pos].father].leaf[0] = endPos;
					deleteTree(node[pos].leaf[0]);
				}
				else
				{
					deleteTree(node[pos].leaf[0]);
					node[pos].deconstruct();
				}
				pos = endPos;
				isChange = true;

				if (verbose)
				{
					char exp[1001] = { 0 };
					recTableExp(pos, 0, exp);
					cout << exp << '\n';
				}
			}
			else if (compareValues(node[pos].leaf[1], node[node[pos].leaf[0]].leaf[1])) //side 1B
			{
				if (verbose)
				{
					char exp[1001] = { 0 };
					recTableExp(node[pos].leaf[0], 0, exp);
					cout << "Absorbtion: " << exp << " v ";
					memset(exp, 0, 1001);
					recTableExp(node[pos].leaf[1], 0, exp);
					cout << exp << " -> ";
				}

				int endPos = node[pos].leaf[1];
				node[endPos].father = node[pos].father;
				if (node[pos].father == -1)
					startPos = endPos;
				if (node[pos].father != -1)
				{
					if (pos == node[node[pos].father].leaf[1])
						node[node[pos].father].leaf[1] = endPos;
					else
						node[node[pos].father].leaf[0] = endPos;
					deleteTree(node[pos].leaf[0]);
				}
				else
				{
					deleteTree(node[pos].leaf[0]);
					node[pos].deconstruct();
				}
				pos = endPos;
				isChange = true;

				if (verbose)
				{
					char exp[1001] = { 0 };
					recTableExp(pos, 0, exp);
					cout << exp << '\n';
				}
			}
		}
		else if (node[node[pos].leaf[1]].symbol == '^') // absorbtion 2
		{
			if (compareValues(node[pos].leaf[0], node[node[pos].leaf[1]].leaf[0])) //side 2A
			{
				if (verbose)
				{
					char exp[1001] = { 0 };
					recTableExp(node[pos].leaf[0], 0, exp);
					cout << "Absorbtion: " << exp << " v ";
					memset(exp, 0, 1001);
					recTableExp(node[pos].leaf[1], 0, exp);
					cout << exp << " -> ";
				}

				int endPos = node[pos].leaf[0];
				node[endPos].father = node[pos].father;
				if (node[pos].father == -1)
					startPos = endPos;
				if (node[pos].father != -1)
				{
					if (pos == node[node[pos].father].leaf[1])
						node[node[pos].father].leaf[1] = endPos;
					else
						node[node[pos].father].leaf[0] = endPos;
					deleteTree(node[pos].leaf[1]);
				}
				else
				{
					deleteTree(node[pos].leaf[1]);
					node[pos].deconstruct();
				}
				pos = endPos;
				isChange = true;

				if (verbose)
				{
					char exp[1001] = { 0 };
					recTableExp(pos, 0, exp);
					cout << exp << '\n';
				}
			}
			else if (compareValues(node[pos].leaf[0], node[node[pos].leaf[1]].leaf[1])) //side 2B
			{
				if (verbose)
				{
					char exp[1001] = { 0 };
					recTableExp(node[pos].leaf[0], 0, exp);
					cout << "Absorbtion: " << exp << " v ";
					memset(exp, 0, 1001);
					recTableExp(node[pos].leaf[1], 0, exp);
					cout << exp << " -> ";
				}

				int endPos = node[pos].leaf[0];
				node[endPos].father = node[pos].father;
				if (node[pos].father == -1)
					startPos = endPos;
				if (node[pos].father != -1)
				{
					if (pos == node[node[pos].father].leaf[1])
						node[node[pos].father].leaf[1] = endPos;
					else
						node[node[pos].father].leaf[0] = endPos;
					deleteTree(node[pos].leaf[1]);
				}
				else
				{
					deleteTree(node[pos].leaf[1]);
					node[pos].deconstruct();
				}
				pos = endPos;
				isChange = true;

				if (verbose)
				{
					char exp[1001] = { 0 };
					recTableExp(pos, 0, exp);
					cout << exp << '\n';
				}
			}
		}
	}

	if (node[pos].symbol == '=')
	{
		if (compareValues(node[pos].leaf[0], node[pos].leaf[1]))
		{
			if (verbose)
			{
				char exp[1001] = { 0 };
				recTableExp(node[pos].leaf[0], 0, exp);
				cout << "Annihilation: " << exp << " = ";
				memset(exp, 0, 1001);
				recTableExp(node[pos].leaf[1], 0, exp);
				cout << exp << " -> ";
			}

			node[pos].symbol = 't';
			deleteTree(node[pos].leaf[0]);
			deleteTree(node[pos].leaf[1]);
			node[pos].leaf[0] = -1;
			node[pos].leaf[1] = -1;

			isChange = true;

			if (verbose)
			{
				char exp[1001] = { 0 };
				recTableExp(pos, 0, exp);
				cout << exp << '\n';
			}
		}
		else if (node[node[pos].leaf[0]].symbol == '^') //other 1
		{
			if (compareValues(node[pos].leaf[1], node[node[pos].leaf[0]].leaf[0])) //side 1A
			{
				if (verbose)
				{
					char exp[1001] = { 0 };
					recTableExp(node[pos].leaf[0], 0, exp);
					cout << "Other: " << exp << " = ";
					memset(exp, 0, 1001);
					recTableExp(node[pos].leaf[1], 0, exp);
					cout << exp << " -> ";
				}

				node[pos].symbol = '>';
				int endPos = node[node[pos].leaf[0]].leaf[1];
				deleteTree(node[node[pos].leaf[0]].leaf[0]);
				node[node[pos].leaf[0]].deconstruct();

				node[pos].leaf[0] = node[pos].leaf[1];
				node[pos].leaf[1] = endPos;
				node[endPos].father = pos;
				startPos = pos;
				isChange = true;

				if (verbose)
				{
					char exp[1001] = { 0 };
					recTableExp(pos, 0, exp);
					cout << exp << '\n';
				}
			}
			else if (compareValues(node[pos].leaf[1], node[node[pos].leaf[0]].leaf[1])) //side 1B
			{
				if (verbose)
				{
					char exp[1001] = { 0 };
					recTableExp(node[pos].leaf[0], 0, exp);
					cout << "Other: " << exp << " = ";
					memset(exp, 0, 1001);
					recTableExp(node[pos].leaf[1], 0, exp);
					cout << exp << " -> ";
				}

				node[pos].symbol = '>';
				int endPos = node[node[pos].leaf[0]].leaf[0];
				deleteTree(node[node[pos].leaf[0]].leaf[1]);
				node[node[pos].leaf[0]].deconstruct();

				node[pos].leaf[0] = node[pos].leaf[1];
				node[pos].leaf[1] = endPos;
				node[endPos].father = pos;
				startPos = pos;
				isChange = true;

				if (verbose)
				{
					char exp[1001] = { 0 };
					recTableExp(pos, 0, exp);
					cout << exp << '\n';
				}
			}
		}
		else if (node[node[pos].leaf[1]].symbol == '^') //other 2
		{
			if (compareValues(node[pos].leaf[0], node[node[pos].leaf[1]].leaf[0])) //side 2A
			{
				if (verbose)
				{
					char exp[1001] = { 0 };
					recTableExp(node[pos].leaf[0], 0, exp);
					cout << "Other: " << exp << " = ";
					memset(exp, 0, 1001);
					recTableExp(node[pos].leaf[1], 0, exp);
					cout << exp << " -> ";
				}

				node[pos].symbol = '>';
				int endPos = node[node[pos].leaf[1]].leaf[1];
				deleteTree(node[node[pos].leaf[1]].leaf[0]);
				node[node[pos].leaf[1]].deconstruct();

				node[pos].leaf[1] = endPos;
				node[endPos].father = pos;
				startPos = pos;
				isChange = true;

				if (verbose)
				{
					char exp[1001] = { 0 };
					recTableExp(pos, 0, exp);
					cout << exp << '\n';
				}
			}
			else if (compareValues(node[pos].leaf[0], node[node[pos].leaf[1]].leaf[1])) //side 2B
			{
				if (verbose)
				{
					char exp[1001] = { 0 };
					recTableExp(node[pos].leaf[0], 0, exp);
					cout << "Other: " << exp << " = ";
					memset(exp, 0, 1001);
					recTableExp(node[pos].leaf[1], 0, exp);
					cout << exp << " -> ";
				}

				node[pos].symbol = '>';
				int endPos = node[node[pos].leaf[1]].leaf[0];
				deleteTree(node[node[pos].leaf[1]].leaf[1]);
				node[node[pos].leaf[1]].deconstruct();

				node[pos].leaf[1] = endPos;
				node[endPos].father = pos;
				startPos = pos;
				isChange = true;

				if (verbose)
				{
					char exp[1001] = { 0 };
					recTableExp(pos, 0, exp);
					cout << exp << '\n';
				}
			}
		}
		else if (node[node[pos].leaf[0]].symbol == 'v') //other 1
		{
			if (compareValues(node[pos].leaf[1], node[node[pos].leaf[0]].leaf[0])) //side 1A
			{
				if (verbose)
				{
					char exp[1001] = { 0 };
					recTableExp(node[pos].leaf[0], 0, exp);
					cout << "Other: " << exp << " = ";
					memset(exp, 0, 1001);
					recTableExp(node[pos].leaf[1], 0, exp);
					cout << exp << " -> ";
				}

				node[pos].symbol = '>';
				int endPos = node[node[pos].leaf[0]].leaf[1];
				deleteTree(node[node[pos].leaf[0]].leaf[0]);
				node[node[pos].leaf[0]].deconstruct();

				node[pos].leaf[0] = endPos;
				node[endPos].father = pos;
				startPos = pos;
				isChange = true;

				if (verbose)
				{
					char exp[1001] = { 0 };
					recTableExp(pos, 0, exp);
					cout << exp << '\n';
				}
			}
			else if (compareValues(node[pos].leaf[1], node[node[pos].leaf[0]].leaf[1])) //side 1B
			{
				if (verbose)
				{
					char exp[1001] = { 0 };
					recTableExp(node[pos].leaf[0], 0, exp);
					cout << "Other: " << exp << " = ";
					memset(exp, 0, 1001);
					recTableExp(node[pos].leaf[1], 0, exp);
					cout << exp << " -> ";
				}

				node[pos].symbol = '>';
				int endPos = node[node[pos].leaf[0]].leaf[0];
				deleteTree(node[node[pos].leaf[0]].leaf[1]);
				node[node[pos].leaf[0]].deconstruct();

				node[pos].leaf[0] = endPos;
				node[endPos].father = pos;
				startPos = pos;
				isChange = true;

				if (verbose)
				{
					char exp[1001] = { 0 };
					recTableExp(pos, 0, exp);
					cout << exp << '\n';
				}
			}
		}
		else if (node[node[pos].leaf[1]].symbol == 'v') //other 1
		{
			if (compareValues(node[pos].leaf[0], node[node[pos].leaf[1]].leaf[0])) //side 1A
			{
				if (verbose)
				{
					char exp[1001] = { 0 };
					recTableExp(node[pos].leaf[0], 0, exp);
					cout << "Other: " << exp << " = ";
					memset(exp, 0, 1001);
					recTableExp(node[pos].leaf[1], 0, exp);
					cout << exp << " -> ";
				}

				node[pos].symbol = '>';
				int endPos = node[node[pos].leaf[1]].leaf[1];
				deleteTree(node[node[pos].leaf[1]].leaf[0]);
				node[node[pos].leaf[1]].deconstruct();

				node[pos].leaf[1] = node[pos].leaf[0];
				node[pos].leaf[0] = endPos;
				node[endPos].father = pos;
				startPos = pos;
				isChange = true;

				if (verbose)
				{
					char exp[1001] = { 0 };
					recTableExp(pos, 0, exp);
					cout << exp << '\n';
				}
			}
			else if (compareValues(node[pos].leaf[0], node[node[pos].leaf[1]].leaf[1])) //side 1B
			{
				if (verbose)
				{
					char exp[1001] = { 0 };
					recTableExp(node[pos].leaf[0], 0, exp);
					cout << "Other: " << exp << " = ";
					memset(exp, 0, 1001);
					recTableExp(node[pos].leaf[1], 0, exp);
					cout << exp << " -> ";
				}

				node[pos].symbol = '>';
				int endPos = node[node[pos].leaf[1]].leaf[0];
				deleteTree(node[node[pos].leaf[1]].leaf[1]);
				node[node[pos].leaf[1]].deconstruct();

				node[pos].leaf[1] = node[pos].leaf[0];
				node[pos].leaf[0] = endPos;
				node[endPos].father = pos;
				startPos = pos;
				isChange = true;

				if (verbose)
				{
					char exp[1001] = { 0 };
					recTableExp(pos, 0, exp);
					cout << exp << '\n';
				}
			}
		}
	}

	if (node[pos].symbol == '>')
	{
		if (node[node[pos].leaf[0]].symbol == 'f' || isContradiction(node[pos].leaf[0]))
		{
			if (verbose)
			{
				char exp[1001] = { 0 };
				recTableExp(node[pos].leaf[0], 0, exp);
				cout << "Contradiction implies: " << exp << " > ";
				memset(exp, 0, 1001);
				recTableExp(node[pos].leaf[1], 0, exp);
				cout << exp << " -> ";
			}

			node[pos].symbol = 't';
			node[node[pos].leaf[0]].deconstruct();
			node[node[pos].leaf[1]].deconstruct();
			node[pos].leaf[0] = -1;
			node[pos].leaf[1] = -1;

			if (verbose)
			{
				char exp[1001] = { 0 };
				recTableExp(pos, 0, exp);
				cout << exp << '\n';
			}
		}
		else if (node[node[pos].leaf[1]].symbol == 't' || isTautology(node[pos].leaf[1]))
		{
			if (verbose)
			{
				char exp[1001] = { 0 };
				recTableExp(node[pos].leaf[0], 0, exp);
				cout << "Tautology is implied: " << exp << " > ";
				memset(exp, 0, 1001);
				recTableExp(node[pos].leaf[1], 0, exp);
				cout << exp << " -> ";
			}

			node[pos].symbol = 't';
			node[node[pos].leaf[0]].deconstruct();
			node[node[pos].leaf[1]].deconstruct();
			node[pos].leaf[0] = -1;
			node[pos].leaf[1] = -1;

			if (verbose)
			{
				char exp[1001] = { 0 };
				recTableExp(pos, 0, exp);
				cout << exp << '\n';
			}
		}
		else if (compareValues(node[pos].leaf[0], node[pos].leaf[1]))
		{
			if (verbose)
			{
				char exp[1001] = { 0 };
				recTableExp(node[pos].leaf[0], 0, exp);
				cout << "Annihilation: " << exp << " > ";
				memset(exp, 0, 1001);
				recTableExp(node[pos].leaf[1], 0, exp);
				cout << exp << " -> ";
			}

			node[pos].symbol = 't';
			deleteTree(node[pos].leaf[0]);
			deleteTree(node[pos].leaf[1]);
			node[pos].leaf[0] = -1;
			node[pos].leaf[1] = -1;

			if (verbose)
			{
				char exp[1001] = { 0 };
				recTableExp(pos, 0, exp);
				cout << exp << '\n';
			}
		}
	}

	if (node[pos].symbol == '!')
	{
		if (node[node[pos].leaf[0]].symbol == '!') //double negation
		{
			if (verbose)
			{
				char exp[1001] = { 0 };
				recTableExp(pos, 0, exp);
				cout << "Double negation: " << exp << " -> ";
			}

			int endPos = node[node[pos].leaf[0]].leaf[0];
			node[endPos].father = node[pos].father;
			if (node[pos].father != -1)
			{
				if (pos == node[node[pos].father].leaf[1])
					node[node[pos].father].leaf[1] = endPos;
				else
					node[node[pos].father].leaf[0] = endPos;
			}
			else
				startPos = endPos;
			node[node[pos].leaf[0]].deconstruct();
			node[pos].deconstruct();
			pos = endPos;
			isChange = true;

			if (verbose)
			{
				char exp[1001] = { 0 };
				recTableExp(pos, 0, exp);
				cout << exp << '\n';
			}
		}
		else if (node[node[pos].leaf[0]].symbol == 't' || isTautology(node[pos].leaf[0]))
		{
			if (verbose)
			{
				char exp[1001] = { 0 };
				recTableExp(pos, 0, exp);
				cout << "Negation of tautology: " << exp << " -> f";
			}

			node[pos].symbol = 'f';
			deleteTree(node[pos].leaf[0]);
			node[pos].leaf[0] = -1;

			isChange = true;
		}
		else if (node[node[pos].leaf[0]].symbol == 'f' || isContradiction(node[pos].leaf[0]))
		{
			if (verbose)
			{
				char exp[1001] = { 0 };
				recTableExp(pos, 0, exp);
				cout << "Negation of contradiction: " << exp << " -> t";
			}

			node[pos].symbol = 't';
			deleteTree(node[pos].leaf[0]);
			node[pos].leaf[0] = -1;

			isChange = true;
		}
	}

	//parsing
	if (node[pos].symbol == '!')
	{
		simplify(node[pos].leaf[0], startPos, isChange);
	}
	else if (node[pos].symbol == '^' || node[pos].symbol == 'v' || node[pos].symbol == '>' || node[pos].symbol == '=' || node[pos].symbol == '*' || node[pos].symbol == '|')
	{
		simplify(node[pos].leaf[0], startPos, isChange);
		simplify(node[pos].leaf[1], startPos, isChange);
	}
}

void eliminateEquiv(int pos, bool &isChange)
{
	if (node[pos].symbol == '=')
	{
		if (verbose)
		{
			char exp[1001] = { 0 };
			recTableExp(node[pos].leaf[0], 0, exp);
			cout << "Reduction: " << exp << " = ";
			memset(exp, 0, 1001);
			recTableExp(node[pos].leaf[1], 0, exp);
			cout << exp << " -> ";
		}

		node[pos].symbol = '^';
		int newStartPos1 = -1, newStartPos2 = -1; //must initialise with -1 for copytree
		copyTree(node[pos].leaf[0], newStartPos1);
		copyTree(node[pos].leaf[1], newStartPos2);

		int impl1 = getFreeNode(1000);
		node[impl1].construct('>', pos, node[pos].leaf[0], node[pos].leaf[1]);
		node[node[pos].leaf[0]].father = impl1;
		node[node[pos].leaf[1]].father = impl1;

		int impl2 = getFreeNode(1000);
		node[impl2].construct('>', pos, newStartPos2, newStartPos1);
		node[newStartPos1].father = impl2;
		node[newStartPos2].father = impl2;

		node[pos].leaf[0] = impl1;
		node[pos].leaf[1] = impl2;

		isChange = true;

		if (verbose)
		{
			char exp[1001] = { 0 };
			recTableExp(pos, 0, exp);
			cout << exp << '\n';
		}
	}

	//parsing
	if (node[pos].symbol == '!')
	{
		eliminateEquiv(node[pos].leaf[0], isChange);
	}
	else if (node[pos].symbol == '^' || node[pos].symbol == 'v' || node[pos].symbol == '>' || node[pos].symbol == '=' || node[pos].symbol == '*' || node[pos].symbol == '|')
	{
		eliminateEquiv(node[pos].leaf[0], isChange);
		eliminateEquiv(node[pos].leaf[1], isChange);
	}
}

void eliminateImpl(int pos, bool &isChange)
{
	if (node[pos].symbol == '>')
	{
		if (verbose)
		{
			char exp[1001] = { 0 };
			recTableExp(node[pos].leaf[0], 0, exp);
			cout << "Reduction: " << exp << " > ";
			memset(exp, 0, 1001);
			recTableExp(node[pos].leaf[1], 0, exp);
			cout << exp << " -> ";
		}

		node[pos].symbol = 'v';
		
		int newPos = getFreeNode(1000);
		node[newPos].construct('!', pos, node[pos].leaf[0], -1);
		node[node[pos].leaf[0]].father = newPos;
		node[pos].leaf[0] = newPos;
		
		isChange = true;

		if (verbose)
		{
			char exp[1001] = { 0 };
			recTableExp(pos, 0, exp);
			cout << exp << '\n';
		}
	}

	//parsing
	if (node[pos].symbol == '!')
	{
		eliminateImpl(node[pos].leaf[0], isChange);
	}
	else if (node[pos].symbol == '^' || node[pos].symbol == 'v' || node[pos].symbol == '>' || node[pos].symbol == '=' || node[pos].symbol == '*' || node[pos].symbol == '|')
	{
		eliminateImpl(node[pos].leaf[0], isChange);
		eliminateImpl(node[pos].leaf[1], isChange);
	}
}

void eliminateBigNeg(int pos, int &startPos, bool &isChange)
{
	if (node[pos].symbol == '!')
	{
		if (node[node[pos].leaf[0]].symbol == 'v')
		{
			if (verbose)
			{
				char exp[1001] = { 0 };
				recTableExp(pos, 0, exp);
				cout << "De Morgan: " << exp << " -> ";
			}

			node[pos].symbol = '^';

			int newPos = getFreeNode(1000);
			node[newPos].construct('!', pos, node[node[pos].leaf[0]].leaf[1], -1);
			node[pos].leaf[1] = newPos;
			node[node[node[pos].leaf[0]].leaf[1]].father = newPos;

			node[node[pos].leaf[0]].symbol = '!';
			node[node[pos].leaf[0]].leaf[1] = -1;

			isChange = true;

			if (verbose)
			{
				char exp[1001] = { 0 };
				recTableExp(pos, 0, exp);
				cout << exp << '\n';
			}
		}
		else if (node[node[pos].leaf[0]].symbol == '^')
		{
			if (verbose)
			{
				char exp[1001] = { 0 };
				recTableExp(pos, 0, exp);
				cout << "De Morgan: " << exp << " -> ";
			}

			node[pos].symbol = 'v';

			int newPos = getFreeNode(1000);
			node[newPos].construct('!', pos, node[node[pos].leaf[0]].leaf[1], -1);
			node[pos].leaf[1] = newPos;
			node[node[node[pos].leaf[0]].leaf[1]].father = newPos;

			node[node[pos].leaf[0]].symbol = '!';
			node[node[pos].leaf[0]].leaf[1] = -1;

			isChange = true;

			if (verbose)
			{
				char exp[1001] = { 0 };
				recTableExp(pos, 0, exp);
				cout << exp << '\n';
			}
		}
		else if (node[node[pos].leaf[0]].symbol == '!') //double negation
		{
			if (verbose)
			{
				char exp[1001] = { 0 };
				recTableExp(pos, 0, exp);
				cout << "Double Negation: " << exp << " -> ";
			}

			int endPos = node[node[pos].leaf[0]].leaf[0];
			node[endPos].father = node[pos].father;
			if (node[pos].father != -1)
			{
				if (pos == node[node[pos].father].leaf[1])
					node[node[pos].father].leaf[1] = endPos;
				else
					node[node[pos].father].leaf[0] = endPos;
			}
			if (node[pos].father == -1)
				startPos = endPos;
			node[node[pos].leaf[0]].deconstruct();
			node[pos].deconstruct();
			pos = endPos;
	
			isChange = true;

			if (verbose)
			{
				char exp[1001] = { 0 };
				recTableExp(pos, 0, exp);
				cout << exp << '\n';
			}
		}
	}

	//parsing
	if (node[pos].symbol == '!')
	{
			eliminateBigNeg(node[pos].leaf[0], startPos, isChange);
	}
	else if (node[pos].symbol == '^' || node[pos].symbol == 'v' || node[pos].symbol == '>' || node[pos].symbol == '=' || node[pos].symbol == '*' || node[pos].symbol == '|')
	{
			eliminateBigNeg(node[pos].leaf[0], startPos, isChange);
			eliminateBigNeg(node[pos].leaf[1], startPos, isChange);
	}
}

void getNNF(char exp[])
{
	int startPos = 0; bool change = false, s_change = false;

	simplify(0, startPos, s_change);
	while (s_change)
	{
		s_change = false;
		simplify(startPos, startPos, s_change);
	}

	eliminateEquiv(startPos, change);
	clearAtomsList();
	updateAtomsList(startPos);
	simplify(0, startPos, s_change);
	while (s_change)
	{
		s_change = false;
		simplify(startPos, startPos, s_change);
	}
	while (change)
	{
		change = false;
		eliminateEquiv(startPos, change);
		clearAtomsList();
		updateAtomsList(startPos);

		simplify(0, startPos, s_change);
		while (s_change)
		{
			s_change = false;
			simplify(startPos, startPos, s_change);
		}
	}
	eliminateImpl(startPos, change);
	simplify(0, startPos, s_change);
	while (s_change)
	{
		s_change = false;
		simplify(startPos, startPos, s_change);
	}
	while (change)
	{
		change = false;
		eliminateImpl(startPos, change);
		simplify(0, startPos, s_change);
		while (s_change)
		{
			s_change = false;
			simplify(startPos, startPos, s_change);
		}
	}

	eliminateBigNeg(startPos, startPos, change);
	simplify(0, startPos, s_change);
	while (s_change)
	{
		s_change = false;
		simplify(startPos, startPos, s_change);
	}
	while (change)
	{
		change = false;
		eliminateBigNeg(startPos, startPos, change);
		simplify(0, startPos, s_change);

		while (s_change)
		{
			s_change = false;
			simplify(startPos, startPos, s_change);
		}
	}

	defragmentTree(startPos);

	exp[0] = 0;
	recTableExp(0, 0, exp); cout <<"exp"<< exp << '\n';
}

void eliminateBigConj(int pos, bool &isChange)
{
	if (node[pos].symbol == '^')
	{
		if (node[node[pos].leaf[0]].symbol == 'v')
		{
			if (verbose)
			{
				char exp[1001] = { 0 };
				recTableExp(node[pos].leaf[0], 0, exp);
				cout << "Distribution: " << exp << " ^ ";
				memset(exp, 0, 1001);
				recTableExp(node[pos].leaf[1], 0, exp);
				cout << exp << " -> ";
			}

			node[pos].symbol = 'v';
			node[node[pos].leaf[0]].symbol = '^';

			int newPos1 = -1; //must initialise with -1 for copytree
			copyTree(node[pos].leaf[1], newPos1);

			int savePos = node[pos].leaf[1];

			int newPos2 = getFreeNode(1000);
			node[newPos2].construct('^', pos, newPos1, node[node[pos].leaf[0]].leaf[0]);
			node[newPos1].father = newPos2;
			node[node[node[pos].leaf[0]].leaf[0]].father = newPos2;
			node[pos].leaf[1] = newPos2;

			node[node[pos].leaf[0]].leaf[0] = savePos;
			node[savePos].father = node[pos].leaf[0];

			isChange = true;

			if (verbose)
			{
				char exp[1001] = { 0 };
				recTableExp(pos, 0, exp);
				cout << exp << '\n';
			}
		}
		if (node[node[pos].leaf[1]].symbol == 'v')
		{
			if (verbose)
			{
				char exp[1001] = { 0 };
				recTableExp(node[pos].leaf[0], 0, exp);
				cout << "Distribution: " << exp << " ^ ";
				memset(exp, 0, 1001);
				recTableExp(node[pos].leaf[1], 0, exp);
				cout << exp << " -> ";
			}

			node[pos].symbol = 'v';
			node[node[pos].leaf[1]].symbol = '^';

			int newPos1 = -1; //must initialise with -1 for copytree
			copyTree(node[pos].leaf[0], newPos1);

			int savePos = node[pos].leaf[0];

			int newPos2 = getFreeNode(1000);
			node[newPos2].construct('^', pos, newPos1, node[node[pos].leaf[1]].leaf[0]);
			node[newPos1].father = newPos2;
			node[node[node[pos].leaf[1]].leaf[0]].father = newPos2;
			node[pos].leaf[0] = newPos2;

			node[node[pos].leaf[1]].leaf[0] = savePos;
			node[savePos].father = node[pos].leaf[0];

			isChange = true;

			if (verbose)
			{
				char exp[1001] = { 0 };
				recTableExp(pos, 0, exp);
				cout << exp << '\n';
			}
		}
	}

	//parsing
	if (node[pos].symbol == '!')
	{
		eliminateBigConj(node[pos].leaf[0], isChange);
	}
	else if (node[pos].symbol == '^' || node[pos].symbol == 'v' || node[pos].symbol == '>' || node[pos].symbol == '=' || node[pos].symbol == '*' || node[pos].symbol == '|')
	{
		eliminateBigConj(node[pos].leaf[0], isChange);
		eliminateBigConj(node[pos].leaf[1], isChange);
	}
}

void eliminateBigDisj(int pos, bool &isChange)
{
	if (node[pos].symbol == 'v')
	{
		if (node[node[pos].leaf[0]].symbol == '^')
		{
			if (verbose)
			{
				char exp[1001] = { 0 };
				recTableExp(node[pos].leaf[0], 0, exp);
				cout << "Distribution: " << exp << " v ";
				memset(exp, 0, 1001);
				recTableExp(node[pos].leaf[1], 0, exp);
				cout << exp << " -> ";
			}

			node[pos].symbol = '^';
			node[node[pos].leaf[0]].symbol = 'v';

			int newPos1 = -1; //must initialise with -1 for copytree
			copyTree(node[pos].leaf[1], newPos1);

			int savePos = node[pos].leaf[1];

			int newPos2 = getFreeNode(1000);
			node[newPos2].construct('v', pos, newPos1, node[node[pos].leaf[0]].leaf[0]);
			node[newPos1].father = newPos2;
			node[node[node[pos].leaf[0]].leaf[0]].father = newPos2;
			node[pos].leaf[1] = newPos2;

			node[node[pos].leaf[0]].leaf[0] = savePos;
			node[savePos].father = node[pos].leaf[0];

			isChange = true;

			if (verbose)
			{
				char exp[1001] = { 0 };
				recTableExp(pos, 0, exp);
				cout << exp << '\n';
			}
		}
		if (node[node[pos].leaf[1]].symbol == '^')
		{
			if (verbose)
			{
				char exp[1001] = { 0 };
				recTableExp(node[pos].leaf[0], 0, exp);
				cout << "Distribution: " << exp << " v ";
				memset(exp, 0, 1001);
				recTableExp(node[pos].leaf[1], 0, exp);
				cout << exp << " -> ";
			}

			node[pos].symbol = '^';
			node[node[pos].leaf[1]].symbol = 'v';

			int newPos1 = -1; //must initialise with -1 for copytree
			copyTree(node[pos].leaf[0], newPos1);

			int savePos = node[pos].leaf[0];

			int newPos2 = getFreeNode(1000);
			node[newPos2].construct('v', pos, newPos1, node[node[pos].leaf[1]].leaf[0]);
			node[newPos1].father = newPos2;
			node[node[node[pos].leaf[1]].leaf[0]].father = newPos2;
			node[pos].leaf[0] = newPos2;

			node[node[pos].leaf[1]].leaf[0] = savePos;
			node[savePos].father = node[pos].leaf[0];

			isChange = true;

			if (verbose)
			{
				char exp[1001] = { 0 };
				recTableExp(pos, 0, exp);
				cout << exp << '\n';
			}
		}
	}

	//parsing
	if (node[pos].symbol == '!')
	{
		eliminateBigDisj(node[pos].leaf[0], isChange);
	}
	else if (node[pos].symbol == '^' || node[pos].symbol == 'v' || node[pos].symbol == '>' || node[pos].symbol == '=' || node[pos].symbol == '*' || node[pos].symbol == '|')
	{
		eliminateBigDisj(node[pos].leaf[0], isChange);
		eliminateBigDisj(node[pos].leaf[1], isChange);
	}
}

void getDNF(char exp[])
{
	int startPos = 0; bool change = false, s_change = false;
	simplify(0, startPos, s_change);
	while (s_change)
	{
		s_change = false;
		simplify(startPos, startPos, s_change);
	}
	eliminateBigConj(startPos, change);
	clearAtomsList();
	updateAtomsList(startPos);
	simplify(0, startPos, s_change);
	while (s_change)
	{
		s_change = false;
		simplify(startPos, startPos, s_change);
	}
	while (change)
	{
		change = false;
		eliminateBigConj(startPos, change);
		clearAtomsList();
		updateAtomsList(startPos);
		simplify(0, startPos, s_change);
		while (s_change)
		{
			s_change = false;
			simplify(startPos, startPos, s_change);
		}
	}

	defragmentTree(startPos);
	exp[0] = 0;
	recTableExp(0, 0, exp); cout << "exp" << exp << '\n';
}

void getCNF(char exp[])
{
	int startPos = 0; bool change = false, s_change = false;

	simplify(0, startPos, s_change);
	while (s_change)
	{
		s_change = false;
		simplify(startPos, startPos, s_change);
	}

	eliminateBigDisj(startPos, change);
	clearAtomsList();
	updateAtomsList(startPos);
	simplify(0, startPos, s_change);
	while (s_change)
	{
		s_change = false;
		simplify(startPos, startPos, s_change);
	}
	while (change)
	{
		change = false;
		eliminateBigDisj(startPos, change);
		clearAtomsList();
		updateAtomsList(startPos);
		simplify(0, startPos, s_change);
		while (s_change)
		{
			s_change = false;
			simplify(startPos, startPos, s_change);
		}
	}

	defragmentTree(startPos);
	exp[0] = 0;
	recTableExp(0, 0, exp); cout << "exp" << exp << '\n';
}


int main()
{
	verbose = true;
	int pos = 0;
	for (int i = 0; i < 26; i++) for (int j = 0; j < 100; j++) atoms[i][j] = -1;
	bool error = false;

	//init atom list
	clearAtomsList();

	//read string
	char inputLine[1001] = { 0 }, expression[1001] = { 0 }, interpretation[10001] = { 0 };
	cin.getline(inputLine, 1000);

	int lineI = 0, intI = 0;
	while (inputLine[lineI] && inputLine[lineI] != '#')
	{
		expression[lineI] = inputLine[lineI];
		lineI++;
	}
	expression[lineI] = 0;
	lineI++;
	while (inputLine[lineI])
	{
		interpretation[intI++] = inputLine[lineI];
		lineI++;
	}
	interpretation[intI] = 0;

	//relax synthax translator
	getStrongExp(expression);
	cout << expression << '\n';

	//build tree
	getTree(expression);

	/*
	//NNF
	char NNFexp[1000];
	getNNF(NNFexp);
	clearTree(1000);
	getTree(NNFexp);
	*/
	/*
	//DNF
	char DNFexp[1000];
	getDNF(DNFexp);
	clearTree(1000);
	getTree(DNFexp);
	*/
	/*
	//CNF
	char CNFexp[1000];
	getCNF(CNFexp);
	clearTree(1000);
	getTree(CNFexp);
	*/
	/*
	int sp = 0; bool change = false;
	simplify(0, sp, change);
	char exp[1000] = { 0 };
	recTableExp(sp, 0, exp);
	cout << "           " << exp << '\n';
	*/

	//drawTree
	for (int i = 0; i < 100; i++)
	{ //create empty char matrix
		for (int j = 0; j < 99; j++)
			treeString[i][j] = ' ';
		treeString[i][99] = 0;
	}
	recTreeString(0, 30, 0);
	for (int i = 0; i < 100; i++)
	{ //print matrix
		bool ok = false;
		for (int j = 0; j < 99; j++)
			if (treeString[i][j] != ' ')
			{
				ok = true;
				break;
			}
		if (!ok)
			break;
		cout << treeString[i] << '\n';
	}

	//graphics
	drawGraphSFML(); //make sure DrawBinTree.exe is in work dir (run the executable directly, not from the IDE)

	for(int i = 0; interpretation[i]; i++)
		if (interpretation[i] == '@')
		{
			memset(interpretation, 0, 10001);
			getAllInterpretations(getAtomCount(), interpretation);
			break;
		}

	//interpretations
	int interpretationCnt;
	if (interpretation[0] != 0)
	{
		cout << "Logic evaluation based on given interpretations:"<< interpretation <<"\n";
		interpretationCnt = readInterpretation(interpretation);

		int tableLen = buildTable();

		for (int i = 0; i < tableLen; i++)
			cout << table[i].exp << '\n';

		//draw table
		printTable(tableLen, interpretationCnt);
	}
	else
		cout << "No interpretations were given.\n";

	//pause
	getchar();
	return 0;
}
